<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="KEYWORDS" content="MDAnalysis" />
		<meta name="robots" content="index,follow" />
		<title>MDAnalysis Documentation</title>
		<style type="text/css" media="screen,projection" href="main.css"></style>
    <!--[if lt IE 5.5000]><style type="text/css">@import "ie50fixes.css";</style><![endif]-->
    <!--[if IE 5.5000]><style type="text/css">@import "ie55fixes.css";</style><![endif]-->
    <!--[if gte IE 6]><style type="text/css">@import "ie60fixes.css";</style><![endif]-->
    <!--[if IE]><script type="text/javascript" src="iefixes.js"></script>
    <meta http-equiv="imagetoolbar" content="no" /><![endif]-->
</head>
	<body>
	  	  <h1 class="firstHeading">MDAnalysis</h1>

<p style="background-color:yellow">NOTE: a more uptodate version of this document can be found in
  the <a href="http://code.google.com/p/mdanalysis/wiki/Documentation">MDAnalysis
  Online Documentation</a>.</p>

<p class="p2"><b>MDAnalysis</b> is <a href="http://www.python.org"><span class="s1">python</span></a> framework to analyze molecular dynamics trajectories generated by Charmm and NAMD. It is currently only useful for geometric analyses, as there is no implemented potential model.</p>
<p class="p2">It is inspired by the Schulten Group's <a href="http://www.ks.uiuc.edu/~jim/mdtools/"><span class="s1">MDtools for python</span></a>, and the source for the <a href="http://www.ks.uiuc.edu/Development/MDTools/catdcd/"><span class="s1">DCD reading code</span></a> is derived from <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a>. MDAnalysis is GPL licensed, except for the dcd reading code (<a href="http://www.ks.uiuc.edu/Development/MDTools/catdcd/license.html"><span class="s1">UIUC Open Source Licence</span></a>) which comes from VMD (and is GPL-compatible). <b>MDAnalysis</b> exposes trajectory data transparently as <a href="http://numpy.scipy.org"><span class="s1">numpy</span></a> arrays and as such it is easily extensible.</p>			
</p>
<p>The latest <a href="http://code.google.com/p/mdanalysis/wiki/Documentation">documention</a> can always be found on the google code website.</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>Contents</h2></div>
<ul>
<li class='toclevel-1'><a href="#Installation"><span class="tocnumber">1</span> <span class="toctext">Installation</span></a>
<ul>
<li class='toclevel-2'><a href="#Getting_the_source"><span class="tocnumber">1.1</span> <span class="toctext">Getting the source</span></a></li>
<li class='toclevel-2'><a href="#Building_the_module"><span class="tocnumber">1.2</span> <span class="toctext">Building the module</span></a>
<ul>
<li class='toclevel-3'><a href="#Intel_compiler_on_Linux"><span class="tocnumber">1.2.1</span> <span class="toctext">Intel compiler on Linux</span></a></li>
<li class='toclevel-3'><a href="#Mac_OS_X"><span class="tocnumber">1.2.2</span> <span class="toctext">Mac OS X</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#Using_MDAnalysis_in_python"><span class="tocnumber">1.3</span> <span class="toctext">Using MDAnalysis in python</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Usage"><span class="tocnumber">2</span> <span class="toctext">Usage</span></a>
<ul>
<li class='toclevel-2'><a href="#To_start"><span class="tocnumber">2.1</span> <span class="toctext">To start</span></a></li>
<li class='toclevel-2'><a href="#AtomGroups"><span class="tocnumber">2.2</span> <span class="toctext">AtomGroups</span></a></li>
<li class='toclevel-2'><a href="#Selections"><span class="tocnumber">2.3</span> <span class="toctext">Selections</span></a></li>
<li class='toclevel-2'><a href="#Segments_and_Residues"><span class="tocnumber">2.4</span> <span class="toctext">Segments and Residues</span></a></li>
<li class='toclevel-2'><a href="#Analyzing_Trajectories"><span class="tocnumber">2.5</span> <span class="toctext">Analyzing Trajectories</span></a></li>
<li class='toclevel-2'><a href="#Timeseries"><span class="tocnumber">2.6</span> <span class="toctext">Timeseries</span></a>
<ul>
<li class='toclevel-3'><a href="#Coordinate_timeseries"><span class="tocnumber">2.6.1</span> <span class="toctext">Coordinate timeseries</span></a></li>
<li class='toclevel-3'><a href="#Correl_timeseries"><span class="tocnumber">2.6.2</span> <span class="toctext">Correl timeseries</span></a></li>
<li class='toclevel-3'><a href="#A_new_method_using_TimeseriesCollection"><span class="tocnumber">2.6.3</span> <span class="toctext">A new method using TimeseriesCollection</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#Helper_functions"><span class="tocnumber">2.7</span> <span class="toctext">Helper functions</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#Examples"><span class="tocnumber">3</span> <span class="toctext">Examples</span></a></li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
</p>
<a name="Installation"></a><h2> Installation </h2>
<p>The source code can be obtained from the SVN repository. The primary dependency is numpy, although pylab is a useful addition to plot analyses generated with MDAnalysis.</p>

<a name="Getting_the_source"></a><h3> Getting the source </h3>
<p>Check out the MDAnalysis directory
</p>
<pre>
svn checkout <a href="http://mdanalysis.googlecode.com/svn/trunk/">http://mdanalysis.googlecode.com/svn/trunk/</a> MDAnalysis
cd MDAnalysis
</pre>
<a name="Building_the_module"></a><h3> Building the module </h3>
<a name="Intel_compiler_on_Linux"></a><h4> Intel/GNU compiler on Linux </h4>
<p>On linux the installation should work out of the box. To use intel compilers/math libraries, edit <tt>setup.cfg</tt> and uncomment the compiler line.
</p>
<pre>python setup.py build
python setup.py install
</pre>
<p>Now you should be ready to <a href="#Using_MDAnalysis_in_python" title="">use MDAnalysis</a>.
</p>
<a name="Mac_OS_X"></a><h4> Mac OS X </h4>
<p>On Mac OS X &gt;= 10.3, modify the following files to make it compile:
</p>
<p>setup.cfg: comment out the intel compiler to default to gcc</p>
<pre>#compiler=intel</pre></dd></dl>
<p>With those changes, build as above:
</p>
<pre>python setup.py build
python setup.py install
</pre>
<a name="Using_MDAnalysis_in_python"></a><h3> Using MDAnalysis in python </h3>
<p>If you've installed MDAnalysis in the standard python modules location, from within the interpreter:
<style>/* GeSHi (c) Nigel McNie 2004 (http://qbnz.com/highlighter) */
.code .imp {font-weight: bold; color: red;}
.code .kw1 {color: #ff7700;font-weight:bold;}
.code .kw2 {color: #008000;}
.code .kw3 {color: #dc143c;}
.code .kw4 {color: #0000cd;}
.code .co1 {color: #808080; font-style: italic;}
.code .coMULTI {color: #808080; font-style: italic;}
.code .es0 {color: #000099; font-weight: bold;}
.code .br0 {color: #66cc66;}
.code .st0 {color: #483d8b;}
.code .nu0 {color: #ff4500;}
.code .me1 {color: black;}
</p>
</style><pre class="code">&gt; <span class="kw1"> from</span> MDAnalysis <span class="kw1">import</span> *</pre>
<a name="Usage"></a><h2> Usage </h2>
<p>The idea behind MDAnalysis is to get trajectory data into numpy arrays, where it can then be easily manipulated using all the power in numpy and <a href="http://www.scipy.org" class="new" title="Scipy">scipy</a>.
</p>
<a name="To_start"></a><h3> To start </h3>
<p><a href="http://ipython.scipy.org" title="IPython">IPython</a> is really helpful here as you can interactively explore the objects and do analysis. The following tutorial will be run from an interactive ipython session.
</p>
<pre>&gt; from MDAnalysis import *
&gt; universe = Universe(psffilename, dcdfilename)
</pre>
<p><tt>psffilename</tt> and <tt>dcdfilename</tt> should specify the full path to the files (although you can also use relative paths - just be aware when running the script from a different directory). You can also just load a psf file, although then you won't have access to any coordinates and a lot of the functions won't work.
</p>
<pre>
&gt; print universe.atoms
&lt;AtomGroup with 27255 atoms&gt;
</pre>
<a name="AtomGroups"></a><h3> AtomGroups </h3>
<p>The primary object you will work with is an <tt>AtomGroup</tt>, which has a number of convenient functions to obtain data from the group, such as:
</p>
<pre>
coordinates() - returns an Nx3 array of atom coordinates
centerOfMass()
centerOfGeometry()
masses() - returns an array of all the masses
charges() - returns an array of all the charges
totalMass()
totalCharge()
momentOfInertia()
principleAxes()
radiusOfGyration()
indices() - returns an array of atom indices (related to the whole system)
</pre>
<p>AtomGroups can also be concatenated using the addition operator.
</p>
<a name="Selections"></a><h3> Selections </h3>
<p>Once you have the <tt>universe</tt> object, you can select atoms (using charmm's atom selection syntax):
</p>
<pre>&gt; kalp = universe.selectAtoms("segid KALP")
</pre>
<p><tt>selectAtoms()</tt> returns <tt>AtomGroups</tt>, so you can use the above functions on them. Selections always return an AtomGroup with atoms sorted according to their index in the psf (this is to ensure that there aren't any duplicates, which can happen with complicated selections).
</p><p><b>Note</b>: you can group subselections using parentheses, but you need to put spaces around the parentheses due to the implementation of the parser I wrote. For example
</p>
<pre>&gt; universe.selectAtoms("segid DMPC and not ( name H* or name O* )")
&lt;AtomGroup with 3420 atoms&gt;
</pre>
<p>If you don't put spaces the selection won't be parsed correctly. Almost all the basic charmm selections work (although currently the distance based ones are slow)
</p><p>Here's a list of all keywords:<br>
<pre>
Simple selections:
   protein, backbone - selects all atoms that belong to a standard set of residues, may not work for esoteric residues
   segid, resid, resname, name, type - single argument describing selection, 
       resid can take a range of numbers separated by a colon (inclusive)
       ie "segid DMPC", "resname LYS", "name CA", "resid 1:5"
	 atom - a selector for a single atom consisting of segid resid atomname
       ie "DMPC 1 C2" selects the C2 carbon of the first residue of the DMPC segment

Boolean:
   not - all atoms not in the selection
       ie "not protein" selects all atoms that aren't part of a protein
   and, or - combine two selections according to the rules of boolean algebra
       ie "protein and not ( resname ALA or resname LYS )" selects all atoms that belong to a protein, 
       but are not in a lysine or alanine residue<br>

Geometric - accounts for periodicity:
   around - selects all atoms a certain cutoff away from another selection
			 ie "around 3.5 protein" selects all atoms not belonging to protein that are 
       within 3.5 Angstroms from the protein
   point - selects all atoms within a cutoff of a point in space, make sure coordinate is separated by spaces
       ie "point 3.5 5.0 5.0 5.0" selects all atoms within 3.5 Angstroms of the coordinate (5.0, 5.0, 5.0)
   prop - selects atoms based on position, using x, y, or z coordinate
       supports the abs keyword (for absolute value) and the following operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=
       ie "prop z &gt;= 5.0" selects all atoms with z coordinate greater than 5.0
          "prop abs z &lt;= 5.0" selects all atoms within -5.0 &lt;= z &lt;= 5.0

Connectivity:
   byres - selects all atoms that are in the same segment and residue as selection
       ie specify the subselection after the byres keyword

Index:
   bynum - selects all atoms within a range of (1-based) inclusive indices
       ie "bynum 1" selects the first atom in the universe
          "bynum 5:10" selects atoms 5 through 10 inclusive
</pre>
<a name="Segments_and_Residues"></a><h3> Segments and Residues </h3>
<p>When you first read in the psf file, MDAnalysis goes through and creates some helper objects for each segment and each residue. For example, I have a system with 5 segments - a protein (KALP), lipids (DMPC), water (BULK), sodium ions (SOD) and chloride ions (CL). The universe object has the following subobjects:
</p>
<pre>universe.KALP
universe.DMPC
universe.BULK
universe.SOD
universe.CL
</pre>
<p>Segments and Residues are all derived from <tt>AtomGroup</tt>, so you can use the functions listed above:
</p>
<pre>&gt; print universe.DMPC.centerOfMass()
[-0.0053126   0.06834258 -0.0073338 ]
</pre>
<p>The DMPC object has a list of all residues (notice the Charmm nonmenclature), and can be accessed using array notation:
</p>
<pre>&gt; universe.DMPC[0]
&lt;Residue 'DMPC', 1&gt;
</pre>
<p>Here's a list of all the KALP residues:
</p>
<pre>&gt; list(universe.KALP)
[&lt;Residue 'CHO', 1&gt;,
 &lt;Residue 'ALA', 2&gt;,
 &lt;Residue 'LYS', 3&gt;,
 &lt;Residue 'LYS', 4&gt;,
 &lt;Residue 'LEU', 5&gt;,
 &lt;Residue 'ALA', 6&gt;,
 &lt;Residue 'LEU', 7&gt;,
 &lt;Residue 'ALA', 8&gt;,
 &lt;Residue 'LEU', 9&gt;,
 &lt;Residue 'ALA', 10&gt;,
 &lt;Residue 'LEU', 11&gt;,
 &lt;Residue 'ALA', 12&gt;,
 &lt;Residue 'LEU', 13&gt;,
 &lt;Residue 'ALA', 14&gt;,
 &lt;Residue 'LYS', 15&gt;,
 &lt;Residue 'LYS', 16&gt;,
 &lt;Residue 'ALA', 17&gt;,
 &lt;Residue 'EAM', 18&gt;]
</pre>
<p>You can also use slicing:
</p>
<pre>&gt; universe.KALP[:5]
[&lt;Residue 'CHO', 1&gt;,
 &lt;Residue 'ALA', 2&gt;,
 &lt;Residue 'LYS', 3&gt;,
 &lt;Residue 'LYS', 4&gt;,
 &lt;Residue 'LEU', 5&gt;]
</pre>
<p>Each residue object returns individual atoms:
</p>
<pre>&gt; universe.KALP[0][0]
&lt; Atom 1: name 'HA' of type '3' of resid 'CHO', 1 and 'KALP'&gt;
</pre>
<p>You can also use the dot notation along with the atom name to select a subset of atoms in an AtomGroup:
</p><p><b>Note</b>: this mostly works, but can be buggy if the atom name conflicts with some other internal variable or starts with a number.
</p>
<pre>&gt; calphas = universe.KALP.CA

&gt; print calphas
&lt;AtomGroup with 17 atoms&gt;

&gt; list(calphas)
[&lt; Atom 6: name 'CA' of type '22' of resname 'ALA', resid 2 and segid 'KALP'&gt;,
 &lt; Atom 16: name 'CA' of type '22' of resname 'LYS', resid 3 and segid 'KALP'&gt;,
 &lt; Atom 38: name 'CA' of type '22' of resname 'LYS', resid 4 and segid 'KALP'&gt;,
 &lt; Atom 60: name 'CA' of type '22' of resname 'LEU', resid 5 and segid 'KALP'&gt;,
 &lt; Atom 79: name 'CA' of type '22' of resname 'ALA', resid 6 and segid 'KALP'&gt;,
 &lt; Atom 89: name 'CA' of type '22' of resname 'LEU', resid 7 and segid 'KALP'&gt;,
 &lt; Atom 108: name 'CA' of type '22' of resname 'ALA', resid 8 and segid 'KALP'&gt;,
 &lt; Atom 118: name 'CA' of type '22' of resname 'LEU', resid 9 and segid 'KALP'&gt;,
 &lt; Atom 137: name 'CA' of type '22' of resname 'ALA', resid 10 and segid 'KALP'&gt;,
 &lt; Atom 147: name 'CA' of type '22' of resname 'LEU', resid 11 and segid 'KALP'&gt;,
 &lt; Atom 166: name 'CA' of type '22' of resname 'ALA', resid 12 and segid 'KALP'&gt;,
 &lt; Atom 176: name 'CA' of type '22' of resname 'LEU', resid 13 and segid 'KALP'&gt;,
 &lt; Atom 195: name 'CA' of type '22' of resname 'ALA', resid 14 and segid 'KALP'&gt;,
 &lt; Atom 205: name 'CA' of type '22' of resname 'LYS', resid 15 and segid 'KALP'&gt;,
 &lt; Atom 227: name 'CA' of type '22' of resname 'LYS', resid 16 and segid 'KALP'&gt;,
 &lt; Atom 249: name 'CA' of type '22' of resname 'ALA', resid 17 and segid 'KALP'&gt;,
 &lt; Atom 259: name 'CA' of type '23' of resname 'EAM', resid 18 and segid 'KALP'&gt;]

&gt; print calphas.coordinates()
[[ -0.40643615   0.20670871 -14.56624699]
 [  2.74141145   1.50868964 -12.98140526]
 [  1.70380127   4.80918837 -11.31853104]
 ...
 [ -2.13122082  -2.77723908  11.90110874]
 [ -1.10523653  -3.76820683  15.34832859]]
</pre>
<p>If you have a segment, you can also name residues:
</p>
<pre>&gt; print universe.KALP.LYS
&lt;ResidueGroup [&lt;Residue 'LYS', 3&gt;, &lt;Residue 'LYS', 4&gt;, &lt;Residue 'LYS', 18&gt;, &lt;Residue 'LYS', 19&gt;]&gt;
</pre>
<p>which will return a ResidueGroup. To get all the c-alphas of the lysine residues:
</p>
<pre>&gt; print universe.KALP.LYS.CA
&lt;AtomGroup with 4 atoms&gt;
</pre>
<p>You should be able to access any subset of atoms using the Segment and Residue classes, which can often times be faster than using <tt>selectAtoms</tt>
</p>
<a name="Analyzing_Trajectories"></a><h3> Analyzing Trajectories </h3>
<p>The trajectory information is stored in the DCDReader object which is part of <tt>universe</tt>:
</p>
<pre>&gt; print universe.dcd
&lt; DCDReader 'kalp16.dcd' with 7500 frames of 27369 atoms (0 fixed) &gt;
</pre>
<p>The DCDReader can be indexed using standard array notation:
</p>
<pre>&gt; print universe.dcd[5]
&lt; Timestep 6 with unit cell dimensions array([ 54.70000076,  54.70000076,  88.48955536,  90.        ,  90.        , 90.],'f') &gt;
</pre>
<p>The current timestep information - frame (timestep number), periodic box dimensions, and coordinates - is stored in a Timestep object:
</p>
<pre>&gt; print universe.dcd.ts
&lt; Timestep 6 with unit cell dimensions array([ 54.70000076,  54.70000076,  88.48955536,  90.        ,  90.        , 90.],'f') &gt;
</pre>
<p>One thing to note is that the dcd object only has one timestep of data read in at a time. To change to a new timestep just change the index passed into the dcd object. The timestep object returned when you index the dcd reader is a pointer to the internal one, so any changes made to the coordinates will be reflected when accessing the internal <tt>ts</tt> object (but not written back to the file, so you can always reread that timestep to reset it).
</p><p>The DCDReader object can be treated as a list, so you can iterate through the trajectory:
</p>
<pre>&gt; for ts in universe.dcd:
      print ts.frame
1
2
3
...
</pre>
<p>You can also iterate through subsets of the trajectory using slice notation.
</p><p>AtomGroup objects have a link to the dcd's <tt>ts</tt> object, so they always return properties based on the currently loaded timestep. For example:
</p>
<pre>&gt; for ts in universe._dcd[:5]:
      print ts.frame, universe.Kalp.centerOfMass()
1 [ 0.19409591  1.28646819 -0.60652838]
2 [ 0.12801227  0.70701863 -0.60693483]
3 [ 0.15608463  0.76454026 -0.57373664]
4 [ 0.04614724  0.75750257 -0.25540986]
5 [ 0.22033799  0.30273071 -0.22080257]
</pre>
<p>This lets you calculate geometric properties over the entire trajectory.
</p>
<a name="Timeseries"></a><h3> Timeseries </h3>
<p>Sometimes iterating through the entire trajectory using python is too slow. MDAnalysis includes tools to extract entire timeseries from the trajectory into numpy arrays so they can be processed in one go (inspired by Charmms correl capabilities).
</p><p>There are two ways of doing this, depending on what properties you wish to extract. The first is simpler, but only extracts timeseries of coordinate data, while the second one is more versatile but requires more initial setup.
</p>
<a name="Coordinate_timeseries"></a><h4> Coordinate timeseries </h4>
<p>This is the easiest way to pull out individual atomic timeseries. All it requires is an AtomGroup.
</p>
<pre>&gt; kalp_coord = universe.dcd.timeseries(universe.KALP)
</pre>
<p>Depending on the size of the trajectory, this call can take from a few seconds to several minutes. One thing to note is that the array for all the coordinates is preallocated, so make sure you have enough memory!! 
</p><p>You can also pass in several options to the timeseries function:
</p>
<pre>&gt; kalp_coord = universe.dcd.timeseries(universe.KALP, start=0, stop=5, skip=1, format="afc")
&gt; print kalp_coord.shape
(314, 6, 3)

</pre>
<p>Most options are self explanatory (note that start and stop are inclusive, and both start and stop can use negative indexing, but start must always be less than or equal to stop), but format needs some explanation. The default timeseries format is (a)tom, (f)rame, (c)oordinate, so above you can see there are 314 atoms, 6 frames, and 3 coordinates per frame per atom.<tt>kalp_coord[0][0]</tt> will return the coordinate of the first atom in the KALP group in the first timestep. Depending on the analysis you will be performing, you might wish the data arranged in another format. All 6 possible combinations of atom, frame and coordinate are allowed (just rearrange the 3 letters).
</p>
<a name="Correl_timeseries"></a><h4> Correl timeseries </h4>
<p>Sometimes you need more involved timeseries. For example, a timeseries of the center of mass of a group, or only the z position of a subset of atoms (for computing a potential profile, for example). This can be done with DCDReader's correl function, which utilized the <tt>Timeseries</tt> module (however, see next section for a new way to retrieve timeseries). First you must build the collection using the TimeseriesCollection class (a default one is created and populated in the main namespace, but you can create as many collections as you wish):
</p>
<pre>&gt; print collection
&lt;TimeseriesCollection with 0 timeseries objects&gt;

&gt; collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
&gt; print collection
&lt;TimeseriesCollection with 1 timeseries object&gt;

&gt; print collection[0]
&lt;CenterOfMass timeseries object is not populated with data&gt;

&gt; data = universe.dcd.correl(collection, stop=5)
&gt; print data.shape
(3, 6)
</pre>
<p>The correl function also takes start, stop and skip as additional arguments. The format argument is not implemented yet - currently the format defaults to (property, frame). So the example above, there is an array for each axes of the center of mass coordinate (data[0] is the timeseries for the x coordinate of the center of mass, data[1] is the y coordinate, and so on).
</p><p>Currently implemented timeseries are Atom, Distance, Angle, Dihedral, CenterOfGeometry, and CenterOfMass. Others can be added but this requires writing some C code. Several of the Timeseries objects require a code argument to specify the data they return:
</p>
<pre>Atom(code, selection) - code can be x, y, z or v (the entire coordinate vector)
Distance(code, selection) - code can be d (actual distance vector) or r (length of vector), 
   doesn't currently take periodic boundary conditions into account
</pre>
<p>Note that each timeseries only pertains to one property (ie to get the dihedral angles of all the residues in a protein you must create a separate Dihedral object for each one). Also, Distance takes 2 atoms, Angle takes 3, and Dihedral takes 4. Atom can take either one atom, or for convenience, an AtomGroup. Because of the way <tt>universe.selectAtoms()</tt> sorts the atoms in the AtomGroup before returning them (this is to eliminate possible duplicates in the selection), you must create multiple selections and concatenate them (which doesn't sort them) before passing into the Timeseries object. <tt>universe.selectAtoms()</tt> does this automatically if you pass multiple strings.
</p><p>For example this won't work as you might expect:
</p>
<pre>&gt; print list(universe.selectAtoms("segid DMPC and ( resid 3 or resid 2 ) and name P"))
[&lt; Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'&gt;,
 &lt; Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'&gt;]
</pre>
<p>Notice how the residues are returned with psf ordering. However, if you do this:
</p>
<pre>&gt; print list(universe.selectAtoms("segid DMPC and resid 3 and name P", "segid DMPC and resid 2 and name P"))
[&lt; Atom 570: name 'P' of type '180' of resid 'DMPC', 3 and 'DMPC'&gt;,
 &lt; Atom 452: name 'P' of type '180' of resid 'DMPC', 2 and 'DMPC'&gt;]
</pre>
<p>The atoms will be ordered the way you specified.
</p><p>You can combine as many timeseries as you want - just make sure to index the resulting timeseries correctly to extract out the relevant data (although see the next section for an easier way to access the resulting timeseries). For example:
</p>
<pre>&gt; collection.clear()
&gt; collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
&gt; collection.addTimeseries(Timeseries.Atom("z", universe.DMPC.P))
&gt; data = universe.dcd.correl(collection, stop=5)
&gt; print data.shape
(93, 6)
</pre>
<p>The first three timeseries correspond to the center of mass of KALP, and the last ninety are the z position timeseries of each phosphate atom in the DMPC segment. If instead of asking for the z position of the phosphate atoms, you did this:
</p>
<pre>&gt; collection.clear()
&gt; collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
&gt; collection.addTimeseries(Timeseries.Atom("v", universe.DMPC.P))
&gt; data = universe.dcd.correl(collection, stop=5)
&gt; print data.shape
(273, 6)
</pre>
<p>Now the first three are again the center of mass of KALP, the next three are the 3D coordinate of the first phosphate, the next three are for the second phosphate, and so on (there are 90 lipids).
</p><p>Once you have them in numpy arrays you can use indexing to pull out the data you want:
</p>
<pre>&gt; print data[3::3].shape
(90, 6)
</pre>
<p>will, for example return the x coordinate timeseries of all the phosphates.
</p>
<a name="A_new_method_using_TimeseriesCollection"></a><h4> A new method using TimeseriesCollection </h4>
<p>The <tt>TimeseriesCollection</tt> object now has a new function, <tt>compute()</tt>, which takes a DCDReader as an argument and generates the timeseries:
</p>
<pre>&gt; collection.clear()
&gt; collection.addTimeseries(Timeseries.CenterOfMass(universe.KALP))
&gt; collection.addTimeseries(Timeseries.Atom("v", universe.DMPC.P))
&gt; collection.compute(universe.dcd, stop=5)
</pre>
<p><tt>compute()</tt> also takes start, stop and skip as arguments. This function will no longer return the timeseries data, instead populating each of the Timeseries objects with their respective timeseries. You can access the collection as a list:
</p>
<pre>&gt; print collection[0]
&lt;CenterOfMass timeseries object is populated with data&gt;
</pre>
<p>The timeseries data is stored in the <tt>__data__</tt> field, and the Timeseries subclasses (Atom, Distance, Dihedral, etc) can be roughly treated as arrays (you can pass them into numpy functions directly, but complicated indexing doesn't work):
</p>
<pre>&gt; kalp_com = collection[0]
&gt; print kalp_com.shape
(3, 6)

&gt; print numpy.average(kalp_com, axis=1)
array([ 0.1456862 ,  0.83971408, -0.49546348])
</pre>
<p>gives you the average center of mass of KALP for the first 6 frames.
</p>
<a name="Helper_functions"></a><h3> Helper functions </h3>
<p>Numpy/Numeric is very powerful. For example, say you want a distance matrix between two sets of atoms:
</p>
<pre>&gt; kalp = universe.KALP.coordinates()
&gt; phosphates = universe.DMPC.P.coordinates()
&gt; dist = numpy.sqrt(numpy.add.reduce(numpy.square(kalp[numpy.newaxis,:] - phosphates[:,numpy.newaxis]), axis=-1))
</pre>
<p><tt>dist</tt> will contain an NxM array of distances between each atom in KALP and each phosphate in the lipid bilayer. But this won't take into account periodic boundaries. A <tt>distance</tt> module in MDAnalysis will do this for you:
</p>
<pre>&gt; box = universe.dcd.ts.dimensions[:3]
&gt; distances.distance_array(kalp, phosphates, box)
</pre>
<p>This may also be faster and more memory efficient for very large coordinate arrays since it avoids the intermediate arrays that the above numpy expression generates.
</p>
<a name="Examples"></a><h2> Examples </h2>
<p>Have a look at the examples subdirectory for some other examples.
<br>Note: These examples were all written using numpy version 1.0.2. Older versions of numpy may not work correctly (since the api wasn't finalized until 1.0).
</p>
<ul><li> Rotational autocorrelation (<a href="../examples/rotational_autocorrelation.py">rotational_autocorrelation.py</a>)</li>
	<li> Lipid order parameters (<a href="../examples/lipid_order_parameters.py">lipid_order_parameters.py</a>)</li>
	<li>Potential profile across double bilayer system (<a href="../examples/potential_profile.py">potential_profile.py</a>)</li>
	<li>Radius of gyration of water in a pure water box (<a href="../examples/radius_of_gyration.py">radius_of_gyration.py</a>)</li>
	<li>Schlitter entropy calculated based using the determinant (<a href="../examples/schlitter_determ.py">schlitter_determ.py</a>) or by calculating the eigenvalues (<a href="../examples/schlitter_quasiharmonic.py">schlitter_quasiharmonic.py</tt>) of the covariance matrix.</li>
</ul>
<br></body>
</html>
